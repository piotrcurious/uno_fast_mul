/* FastMathToolkit.h

Single-file Arduino-friendly header implementing fast fixed-point operations that benefit from precomputed lookup tables (log2/exp2, trig, perspective, stereographic, etc.). The tables are assumed to be generated by the provided generate_tables.py script and saved into a header (e.g. arduino_tables_generated.h).

Uses Q8.8 fixed-point for log/exp pipeline by default (configurable).

Provides fast multiplication/division/power via log/exp LUTs.

Wraps trig tables (sin/cos) with helpers for Q15 angular input.

Provides perspective and stereographic lookup wrappers.

Small, inline functions for Arduino (AVR) with PROGMEM reads.


Usage: 1) Run the provided generate_tables.py to produce arduino_tables_generated.h. 2) Put that header in the project and #include it before this file or change INCLUDE_TABLES to point to it. 3) #include "FastMathToolkit.h" and call the helpers.

Example: #include "arduino_tables_generated.h" #include "FastMathToolkit.h"

uint32_t prod = FastMath::mul_u16_approx(12345, 23456);

Notes: - Functions return approximate results. The library trades precision for speed and small memory footprint. - All table names and Q-formats match the defaults used by the generator (log2_table_q8, exp2_table_q8, msb_table, sin_table_q15, etc.).

Copyright: MIT-style minimal notice */

#ifndef FAST_MATH_TOOLKIT_H #define FAST_MATH_TOOLKIT_H

#include <stdint.h> #include <limits.h>

#ifdef ARDUINO #include <avr/pgmspace.h> #endif

// By default expect generator output in this header name. #ifndef INCLUDE_TABLES #define INCLUDE_TABLES "arduino_tables_generated.h" #endif #include INCLUDE_TABLES

namespace FastMath {

// --- Configuration (tweak if you generated different Q) --- #ifndef FASTMATH_LOG_Q #define FASTMATH_LOG_Q 8        // log tables are Q8.8 #endif #ifndef FASTMATH_SIN_Q #define FASTMATH_SIN_Q 15       // sin/cos tables Q15 #endif

// Convenience integer constants static_assert(FASTMATH_LOG_Q <= 16, "FASTMATH_LOG_Q must be <= 16");

// Read helpers which work with PROGMEM arrays or normal const arrays. static inline uint8_t read_u8_prog(const uint8_t *arr, uint16_t idx) { #ifdef ARDUINO return pgm_read_byte(&arr[idx]); #else return arr[idx]; #endif } static inline uint16_t read_u16_prog(const uint16_t *arr, uint16_t idx) { #ifdef ARDUINO return pgm_read_word(&arr[idx]); #else return arr[idx]; #endif } static inline int16_t read_s16_prog(const int16_t *arr, uint16_t idx) { #ifdef ARDUINO return (int16_t)pgm_read_word(&arr[idx]); #else return arr[idx]; #endif }

// --- Low-level helpers for normalization and lookup ---

// Find floor(log2(v)) for a 32-bit unsigned value using msb_table (assumed 256 entries) static inline int fast_msb32(uint32_t v) { if (v == 0) return -1; // undefined for zero // fast path for 16-bit or less if (v & 0xFFFF0000u) { uint16_t hi = (uint16_t)(v >> 16); if (hi) { uint8_t t = read_u8_prog(msb_table, hi >> 8); if (t != 0 || (hi >> 8) != 0) { // hi >> 8 nonzero -> index 1..255 } // simpler: use two-stage: check top byte uint8_t top = (uint8_t)(hi >> 8); if (top) return 24 + (int)read_u8_prog(msb_table, top); return 16 + (int)read_u8_prog(msb_table, (uint8_t)hi); } else { uint16_t lo_hi = (uint16_t)(v >> 8); uint8_t top = (uint8_t)(lo_hi >> 8); if (top) return 16 + (int)read_u8_prog(msb_table, top); } } // else value fits in 16 bits or less uint16_t low16 = (uint16_t)v; uint8_t b1 = (uint8_t)(low16 >> 8); if (b1) return 8 + (int)read_u8_prog(msb_table, b1); return (int)read_u8_prog(msb_table, (uint8_t)low16); }

// Normalize a 32-bit unsigned integer so that mantissa is 8-bit with MSB set // Returns exponent e and mantissa m in [128..255]. For v==0 returns (0,0). static inline void normalize_to_mant8(uint32_t v, int *out_e, uint8_t *out_m) { if (v == 0) { *out_e = 0; *out_m = 0; return; } int e = fast_msb32(v); // floor(log2(v)) // want mantissa m = floor(v >> (e - 7)) & 0xFF when e >= 7 if (e >= 7) { uint32_t shifted = v >> (e - 7); uint8_t m = (uint8_t)(shifted & 0xFFu); *out_e = e; *out_m = (m == 0) ? 128 : m; // ensure non-zero } else { // left shift when value small uint32_t shifted = v << (7 - e); uint8_t m = (uint8_t)(shifted & 0xFFu); *out_e = e; *out_m = (m == 0) ? 128 : m; } }

// Compute fixed-point Q8.8 log2(v) for v>0 using tables: msb_table + log2_table_q8 // Returns a signed 32-bit Q8.8 value. If v==0 returns INT32_MIN to indicate -inf. static inline int32_t fast_log2_q8_u32(uint32_t v) { if (v == 0) return INT32_MIN; // represent -infty int e; uint8_t m; normalize_to_mant8(v, &e, &m); // m in [128..255] // lookup log2(m) from table: table stores log2(i) * 2^Q (for i>=1) uint16_t l = read_u16_prog(log2_table_q8, m); // combine: log2(v) â‰ˆ (e - 7) + log2(m) int32_t res = ((e - 7) << FASTMATH_LOG_Q) + (int32_t)l; return res; }

// Evaluate 2^{y_q8} where y_q8 is Q8.8 signed. Result is u32 approximate. // Uses exp2_table_q8 (size 256) where entry f = round(2^{f/256} * 256) static inline uint32_t fast_exp2_q8_to_u32(int32_t y_q8) { // handle -inf sentinel if (y_q8 == INT32_MIN) return 0; int32_t ip = y_q8 >> FASTMATH_LOG_Q;   // integer exponent (signed) uint16_t frac = (uint16_t)(y_q8 & ((1 << FASTMATH_LOG_Q) - 1)); uint32_t frac_val = (uint32_t)read_u16_prog(exp2_table_q8, frac); // Q8 scaled

if (ip >= 0) {
    if (ip > 24) return UINT32_MAX; // avoid overflow (unsafe to shift more)
    // result = (frac_val * (1<<ip)) / 256
    uint32_t tmp = (frac_val * (1u << ip));
    return (tmp >> FASTMATH_LOG_Q);
} else {
    int s = -ip;
    int denom_shift = FASTMATH_LOG_Q + s; // divide by 256 * 2^s
    if (denom_shift >= 31) return 0;
    uint32_t tmp = (frac_val >> denom_shift);
    return tmp; // already scaled down
}

}

// High-level approximate multiplication for unsigned 16-bit values -> 32-bit result static inline uint32_t mul_u16_approx(uint16_t a, uint16_t b) { if (a == 0 || b == 0) return 0; int32_t la = fast_log2_q8_u32((uint32_t)a); int32_t lb = fast_log2_q8_u32((uint32_t)b); if (la == INT32_MIN || lb == INT32_MIN) return 0; int32_t sum = la + lb; // Q8.8 + Q8.8 -> Q8.8 return fast_exp2_q8_to_u32(sum); }

// High-level approximate division for unsigned 32-bit dividend by 16-bit divisor -> 32-bit result static inline uint32_t div_u32_by_u16_approx(uint32_t num, uint16_t den) { if (den == 0) return UINT32_MAX; if (num == 0) return 0; int32_t ln = fast_log2_q8_u32(num); int32_t ld = fast_log2_q8_u32((uint32_t)den); if (ln == INT32_MIN) return 0; if (ld == INT32_MIN) return UINT32_MAX; // div by zero-ish int32_t diff = ln - ld; // Q8.8 return fast_exp2_q8_to_u32(diff); }

// Power: compute a^k where k is integer (positive or negative) static inline uint32_t pow_u16_int_approx(uint16_t a, int k) { if (a == 0) return 0; if (k == 0) return 1; int32_t la = fast_log2_q8_u32((uint32_t)a); if (la == INT32_MIN) return 0; int32_t y = la * (int32_t)k; // Q8.8 * integer -> Q8.8 return fast_exp2_q8_to_u32(y); }

// --- Trig wrappers (sin/cos) --- // sin_table_q15 and cos_table_q15 assumed to exist with Q15 values. // Angle convention: input angle is 0..65535 mapping to [0, 2*pi).

static inline int16_t sin_q15_from_u16angle(uint16_t angle) { // map 0..65535 to 0..sin_table_len-1 const uint32_t N = (uint32_t) (sizeof(sin_table_q15) / sizeof(sin_table_q15[0])); // Compute index = (angle * N) >> 16 uint32_t idx = ((uint32_t)angle * N) >> 16; if (idx >= N) idx = 0; return read_s16_prog(sin_table_q15, (uint16_t)idx); } static inline int16_t cos_q15_from_u16angle(uint16_t angle) { const uint32_t N = (uint32_t) (sizeof(cos_table_q15) / sizeof(cos_table_q15[0])); uint32_t idx = ((uint32_t)angle * N) >> 16; if (idx >= N) idx = 0; return read_s16_prog(cos_table_q15, (uint16_t)idx); }

// --- Perspective & stereographic --- // perspective_scale_table_q8: returns scale in Qpersp (we assume Q = persp table q) static inline uint32_t perspective_scale_from_index(uint16_t idx) { // table size detection const uint32_t N = (uint32_t) (sizeof(perspective_scale_table_q8) / sizeof(perspective_scale_table_q8[0])); if (idx >= N) idx = N - 1; return (uint32_t) read_u16_prog(perspective_scale_table_q8, idx); }

static inline uint16_t stereographic_from_index(uint16_t idx) { const uint32_t N = (uint32_t) (sizeof(stereo_radial_table_q12) / sizeof(stereo_radial_table_q12[0])); if (idx >= N) idx = N - 1; return (uint16_t) read_u16_prog(stereo_radial_table_q12, idx); }

// --- Utilities / fallbacks --- // Fast approx multiply for generic 32-bit values with clamping to u32. This function // uses the u16 pipeline by downscaling inputs if needed. It is a convenience wrapper. static inline uint32_t mul_u32_approx(uint32_t a, uint32_t b) { if (a == 0 || b == 0) return 0; // choose shift so both fit in 16 bits (preserve magnitude) int sa = fast_msb32(a); int sb = fast_msb32(b); int shift = 0; if (sa > 15) shift = sa - 15; if (sb > 15) shift = max(shift, sb - 15); uint16_t a16 = (uint16_t)(a >> shift); uint16_t b16 = (uint16_t)(b >> shift); uint32_t r = mul_u16_approx(a16, b16); // scale back if (shift >= 16) return 0; return (r << (2 * shift)); // note: may overflow }

// Select helpers static inline int max(int x, int y) { return (x > y) ? x : y; }

// --- API exports (C compatibility) --- #ifdef __cplusplus extern "C" { #endif

// Provide simple C prototypes that call the inline C++ functions above static inline uint32_t FastMath_mul_u16_approx(uint16_t a, uint16_t b) { return FastMath::mul_u16_approx(a,b); } static inline uint32_t FastMath_div_u32_by_u16_approx(uint32_t n, uint16_t d) { return FastMath::div_u32_by_u16_approx(n,d); } static inline uint32_t FastMath_pow_u16_int_approx(uint16_t a, int k) { return FastMath::pow_u16_int_approx(a,k); } static inline int16_t FastMath_sin_q15_from_u16angle(uint16_t angle) { return FastMath::sin_q15_from_u16angle(angle); } static inline int16_t FastMath_cos_q15_from_u16angle(uint16_t angle) { return FastMath::cos_q15_from_u16angle(angle); }

#ifdef __cplusplus } #endif

} // namespace FastMath

#endif // FAST_MATH_TOOLKIT_H
