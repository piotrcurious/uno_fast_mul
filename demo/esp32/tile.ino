// ESP32_TextTransform_Segmented.ino
// Segmented (tile) framebuffer renderer for ESP32 + TFT_eSPI
// - Uses PROGMEM tables and glyph bitmaps generated by the Python generator
// - Renders per-glyph transformed pixels into a reusable tile buffer (no full-frame buffer)
// - Uses fast log-add-exp multiply pipeline for scaling (log2_table_q8 + exp2_table_q8)
// - Benchmarks frame time, mul error stats, and heap usage
//
// Requirements: TFT_eSPI library, arduino_tables.h / .c generated by the generator and placed in the sketch folder.

#include <Arduino.h>
#include <TFT_eSPI.h>
#include <esp_heap_caps.h>

TFT_eSPI tft = TFT_eSPI();

// Include generated tables & glyphs
#include "arduino_tables.h" // produced by generator; must define GLYPH_BITMAPS, GLYPH_CHAR_LIST, GLYPH_WIDTH, GLYPH_HEIGHT, GLYPH_COUNT, and numeric tables

// ------------------ Q / table config (match generator settings) ------------------
#define LOG_Q 8
#define LOG_SCALE (1<<LOG_Q)
#define SIN_Q 15
#define SIN_SIZE 512

// ------------------ Fast log/exp multiply pipeline (same as generator's convention) ------------------
static inline uint8_t fast_msb16(uint16_t v) {
  if (v >> 8) return 8 + msb_table[v >> 8];
  return msb_table[v & 0xFF];
}

static inline void normalize_to_mant8(uint16_t v, uint8_t &mant8, int8_t &e_out) {
  if (v == 0) { mant8 = 0; e_out = -127; return; }
  uint8_t e = fast_msb16(v);
  uint32_t tmp = ((uint32_t)v << (15 - e)) >> 8;
  mant8 = (uint8_t)tmp;
  e_out = (int8_t)e;
}

static inline int32_t fast_log2_q8_8(uint16_t v) {
  if (v == 0) return INT32_MIN;
  uint8_t m; int8_t e;
  normalize_to_mant8(v, m, e);
  uint16_t logm = log2_table_q8[m];
  return (((int32_t)(e - 7) << LOG_Q) + (int32_t)logm);
}

static inline uint32_t fast_exp2_from_q8_8(int32_t log_q8_8) {
  if (log_q8_8 <= INT32_MIN/2) return 0;
  int32_t integer = log_q8_8 >> LOG_Q;
  uint8_t frac = (uint8_t)(log_q8_8 & 0xFF);
  uint16_t frac_val = exp2_table_q8[frac];
  if (integer >= 31) return 0xFFFFFFFFUL;
  else if (integer >= 0) {
    uint32_t v = ((uint32_t)frac_val << integer) >> LOG_Q;
    return v;
  } else {
    int shift = -integer;
    uint32_t v = ((uint32_t)frac_val) >> (LOG_Q + shift - 0);
    return v;
  }
}

static inline uint32_t fast_log_mul_u16(uint16_t a, uint16_t b) {
  if (a == 0 || b == 0) return 0;
  int32_t la = fast_log2_q8_8(a);
  int32_t lb = fast_log2_q8_8(b);
  return fast_exp2_from_q8_8(la + lb);
}

// ------------------ Sin/cos helpers ------------------
static inline uint16_t angle_to_index(float angle) {
  while (angle < 0) angle += 2.0f * PI;
  while (angle >= 2.0f * PI) angle -= 2.0f * PI;
  return (uint16_t)((angle / (2.0f * PI)) * (float)SIN_SIZE);
}
static inline int16_t sin_q15(uint16_t idx) { return sin_table_q15[idx % SIN_SIZE]; }
static inline int16_t cos_q15(uint16_t idx) { return cos_table_q15[idx % SIN_SIZE]; }

// ------------------ Glyph helpers (from generated header) ------------------
extern const char GLYPH_CHAR_LIST[];    // char list
extern const uint8_t GLYPH_BITMAPS[];   // flattened bitmaps (glyph_count * gw bytes)
extern const uint8_t GLYPH_WIDTH;
extern const uint8_t GLYPH_HEIGHT;
extern const uint16_t GLYPH_COUNT;

static int glyph_index_for_char(char c) {
  for (uint16_t i = 0; i < GLYPH_COUNT; ++i) {
    if (GLYPH_CHAR_LIST[i] == c) return (int)i;
  }
  return -1;
}

// ------------------ Tile segmentation parameters ------------------
// Tune these; 64x64 is a good balance on ESP32 (8KB buffer)
const int TILE_W = 64;
const int TILE_H = 64;

// We'll compute tile grid from display size
int tiles_x, tiles_y;

// Reusable tile buffer (allocated in DMA-capable memory)
uint16_t *tile_buf = nullptr;

// ------------------ Demo text ------------------
const char* TEXT_ROWS[] = {
  "ESP32 DMA TILED FB",
  "FAST LOG MUL TRANSFORMS",
  "PROGMEM GLYPHS"
};
const uint8_t ROWS = sizeof(TEXT_ROWS) / sizeof(TEXT_ROWS[0]);

// ------------------ Benchmark accumulators ------------------
uint64_t bench_total_time_us = 0;
uint32_t bench_frames = 0;
uint32_t bench_mul_samples = 0;
double bench_mul_error_rel_sum = 0.0;
uint32_t bench_mul_error_max = 0;

// bench helper records error relative to exact multiply
static inline void bench_record_mul(uint16_t a, uint16_t b) {
  uint32_t exact = (uint32_t)a * (uint32_t)b;
  uint32_t approx = fast_log_mul_u16(a, b);
  uint32_t err_abs = (approx > exact) ? (approx - exact) : (exact - approx);
  bench_mul_samples++;
  double rel = exact ? ((double)err_abs / (double)exact) : 0.0;
  bench_mul_error_rel_sum += rel;
  if (err_abs > bench_mul_error_max) bench_mul_error_max = err_abs;
}

// ------------------ Utility to clear tile buffer ------------------
static inline void clear_tile(uint16_t color = 0x0000) {
  uint32_t n = (uint32_t)TILE_W * (uint32_t)TILE_H;
  for (uint32_t i=0;i<n;++i) tile_buf[i] = color;
}

// ------------------ Render a glyph's transformed pixels into a single tile buffer ------------------
// tile origin (tx0,ty0) are screen coords of tile's top-left
void rasterize_glyph_into_tile(char ch, int16_t cx, int16_t cy, float scale_f, float angle_rad, int16_t tx0, int16_t ty0) {
  int gidx = glyph_index_for_char(ch);
  if (gidx < 0) return;
  const uint8_t gw = GLYPH_WIDTH;
  const uint8_t gh = GLYPH_HEIGHT;

  // Map scale_f (float) to Q8.8 integer
  uint16_t scale_q8 = (uint16_t)round(scale_f * (1 << LOG_Q));
  // simple perspective scaling by vertical position via perspective table
  uint16_t persp_idx = (uint16_t)((cy / (float)tft.height()) * 255.0f);
  if (persp_idx > 255) persp_idx = 255;
  uint16_t persp_q8 = perspective_scale_table_q8[persp_idx];
  // combined scale in Q8.8 (approx) - use fast log mul, then right-shift LOG_Q to remain Q8.8
  uint32_t combined_q16 = fast_log_mul_u16(scale_q8, persp_q8); // result approx in integer domain
  uint16_t combined_scale_q8 = (uint16_t)(combined_q16 >> LOG_Q); // keep Q8.8
  bench_record_mul(scale_q8, persp_q8);

  // rotation q15
  uint16_t aidx = angle_to_index(angle_rad);
  int16_t cosv = cos_q15(aidx);
  int16_t sinv = sin_q15(aidx);

  // iterate glyph columns/rows
  // GLYPH_BITMAPS flat layout: gidx * gw + col
  for (uint8_t col = 0; col < gw; ++col) {
    uint8_t colbyte = GLYPH_BITMAPS[gidx * gw + col];
    if (colbyte == 0) continue;
    for (uint8_t row = 0; row < gh; ++row) {
      if (!(colbyte & (1 << row))) continue;
      // source coords centered at glyph center
      int16_t sx = (int16_t)col - (gw/2);
      int16_t sy = (int16_t)row - (gh/2);

      // Q8.8 coordinates
      int32_t sx_q8 = ((int32_t)sx) << LOG_Q;
      int32_t sy_q8 = ((int32_t)sy) << LOG_Q;

      // absolute and clamp to 16-bit for fast_mul inputs
      uint16_t asx = (uint16_t)min((uint32_t)abs((int32_t)sx_q8), (uint32_t)65535);
      uint16_t asy = (uint16_t)min((uint32_t)abs((int32_t)sy_q8), (uint32_t)65535);

      uint32_t sx_scaled = fast_log_mul_u16(asx, combined_scale_q8); // approx Q8.8*Q8.8 -> Q? (we'll shift)
      uint32_t sy_scaled = fast_log_mul_u16(asy, combined_scale_q8);
      bench_record_mul(asx, combined_scale_q8);
      bench_record_mul(asy, combined_scale_q8);

      int32_t sxs = (sx_q8 < 0) ? -(int32_t)sx_scaled : (int32_t)sx_scaled;
      int32_t sys = (sy_q8 < 0) ? -(int32_t)sy_scaled : (int32_t)sy_scaled;

      // rotate: (x',y') = (x*cos - y*sin, x*sin + y*cos)
      // sxs/sys are Q8.8; cos/sin are Q15 => (Q8.8 * Q15) >> 15 -> Q8.8
      int32_t rx_q8 = ( (sxs * (int32_t)cosv) - (sys * (int32_t)sinv) ) >> SIN_Q;
      int32_t ry_q8 = ( (sxs * (int32_t)sinv) + (sys * (int32_t)cosv) ) >> SIN_Q;

      // final screen coordinate (integer)
      int16_t fx = cx + (int16_t)(rx_q8 >> LOG_Q);
      int16_t fy = cy + (int16_t)(ry_q8 >> LOG_Q);

      // if final pixel intersects tile, write to tile buffer
      if (fx >= tx0 && fx < tx0 + TILE_W && fy >= ty0 && fy < ty0 + TILE_H) {
        int16_t lx = fx - tx0;
        int16_t ly = fy - ty0;
        uint32_t idx = (uint32_t)ly * TILE_W + (uint32_t)lx;
        tile_buf[idx] = 0xFFFF; // white pixel (RGB565)
      }
    }
  }
}

// ------------------ Frame rendering: loop over tiles ------------------
void render_frame_tiles() {
  uint32_t t0 = micros();

  // clear bench per frame? we accumulate across multiple frames then print stats periodically
  // iterate tile grid
  for (int ty = 0; ty < tiles_y; ++ty) {
    int16_t ty0 = ty * TILE_H;
    for (int tx = 0; tx < tiles_x; ++tx) {
      int16_t tx0 = tx * TILE_W;
      // clear tile
      clear_tile(0x0000);

      // rasterize only glyphs that intersect this tile
      for (uint8_t r = 0; r < ROWS; ++r) {
        const char* s = TEXT_ROWS[r];
        uint16_t len = strlen(s);
        int16_t baseline_x = tft.width() / 2;
        int16_t baseline_y = 20 + r * 80;
        for (uint16_t i=0;i<len;++i) {
          char ch = s[i];
          int16_t cx = baseline_x - (len * GLYPH_WIDTH)/2 + i * (GLYPH_WIDTH + 1) + GLYPH_WIDTH/2;
          int16_t cy = baseline_y;

          // estimate bounding box of transformed glyph
          // A conservative bbox: max extent after scale = ceil( max(|sx|,|sy|) * combined_scale ) + rotation margin
          // For speed just approximate using glyph diagonal scaled by simple sbase factor
          float sbase = 0.8f + 0.6f * sin(frameCount * 0.02f + i * 0.3f); // used same animation but we compute again below
          // quick test if char might intersect tile: check center distance less than tile diag + margin
          int16_t dx = cx - (tx0 + TILE_W/2);
          int16_t dy = cy - (ty0 + TILE_H/2);
          int32_t dist2 = (int32_t)dx*dx + (int32_t)dy*dy;
          int32_t maxRad = max(TILE_W, TILE_H) + 64; // loose margin
          if ((int64_t)dist2 > (int64_t)maxRad * (int64_t)maxRad) {
            // far away from tile center â€” skip (cheap)
          } else {
            // render glyph into tile buffer
            float scale_f = 0.8f + 0.6f * sin(frameCount * 0.02f + i * 0.3f);
            float angle = frameAngle + 0.15f * sin(i * 0.25f + frameCount * 0.01f);
            rasterize_glyph_into_tile(ch, cx, cy, scale_f, angle, tx0, ty0);
          }
        }
      }

      // push tile to display (only push every tile; could implement dirty-check to avoid pushing empty tiles)
      tft.pushImage(tx0, ty0,
                    (tx0 + TILE_W <= tft.width()) ? TILE_W : (tft.width() - tx0),
                    (ty0 + TILE_H <= tft.height()) ? TILE_H : (tft.height() - ty0),
                    tile_buf);
    }
  }

  uint32_t t1 = micros();
  uint32_t dt = t1 - t0;
  bench_total_time_us += dt;
  bench_frames++;

  // print bench every 30 frames
  if (bench_frames % 30 == 0) {
    float avg_ms = (bench_total_time_us / (float)bench_frames) / 1000.0f;
    float avg_rel_err = (bench_mul_samples) ? (bench_mul_error_rel_sum / (double)bench_mul_samples) : 0.0;
    Serial.printf("Frames=%u avg_frame_ms=%.2f fps=%.2f heap=%u mul_samples=%u avg_rel_err=%.6f max_abs_err=%u\n",
                  bench_frames, avg_ms, 1000.0f/avg_ms, ESP.getFreeHeap(), bench_mul_samples, (float)avg_rel_err, bench_mul_error_max);
    // Reset some accumulators optionally
    // bench_total_time_us = 0; bench_frames = 0; bench_mul_samples = 0; bench_mul_error_rel_sum = 0; bench_mul_error_max = 0;
  }
}

// ------------------ Globals for animation ------------------
uint32_t frameCount = 0;
float frameAngle = 0.0f;

// ------------------ Setup & loop ------------------
void setup() {
  Serial.begin(115200);
  delay(10);
  tft.init();
  tft.setRotation(1);
  tft.fillScreen(TFT_BLACK);

  // compute tiles
  tiles_x = (tft.width() + TILE_W - 1) / TILE_W;
  tiles_y = (tft.height() + TILE_H - 1) / TILE_H;
  Serial.printf("Display %dx%d tiles %dx%d (TILE %dx%d)\n", tft.width(), tft.height(), tiles_x, tiles_y, TILE_W, TILE_H);

  // allocate tile buffer in DMA-capable memory (MALLOC_CAP_DMA)
  size_t bufBytes = (size_t)TILE_W * (size_t)TILE_H * sizeof(uint16_t);
  tile_buf = (uint16_t*)heap_caps_malloc(bufBytes, MALLOC_CAP_DMA | MALLOC_CAP_8BIT);
  if (!tile_buf) {
    Serial.printf("tile_buf alloc failed (%u bytes). Try smaller TILE_W/H\n", (unsigned)bufBytes);
    while(1) delay(1000);
  }

  // quick sanity clear
  clear_tile(0x0000);
}

void loop() {
  // render frame via segmented tiles
  render_frame_tiles();
  frameCount++;
  frameAngle += 0.02f;
  // small delay if desired
  // delay(8);
}
