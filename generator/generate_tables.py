#!/usr/bin/env python3
"""
generate_tables.py

Generates PROGMEM-friendly C header with lookup tables useful for:
 - fast log/exp-based multiplication (msb, log2, exp2)
 - trig (sin, cos)
 - perspective scale (focal/(focal+z))
 - sphere coordinates (theta sin/cos, phi sin/cos via shared sin/cos table)
 - base constants (PI, 2PI in chosen Q formats)
 - optional angle (atan-approx) table and stereographic projection table

No external dependencies. Use --out to choose output path.
"""

from pathlib import Path
import math
import argparse
import textwrap

# ---------------------- Utilities ----------------------
def qscale(q): return 1 << q

def clamp_int(x, lo, hi):
    return max(lo, min(hi, int(x)))

def fmt_c_array(ctype, name, values, per_line=12, progmem_macro="PROGMEM"):
    # Use decimal literals for readability
    lines = []
    for i in range(0, len(values), per_line):
        chunk = values[i:i+per_line]
        lines.append("  " + ", ".join(str(int(v)) for v in chunk) + ("," if i+per_line < len(values) else ""))
    body = "\n".join(lines)
    return f"const {ctype} {progmem_macro} {name}[{len(values)}] = {{\n{body}\n}};\n"

# ---------------------- Generators ----------------------
def gen_msb_table(size=256):
    tbl = []
    for i in range(size):
        tbl.append(0 if i == 0 else int(math.floor(math.log2(i))))
    return tbl

def gen_log2_table(size=256, q=8):
    scale = qscale(q)
    tbl = []
    for i in range(size):
        if i < 1:
            tbl.append(0)
        else:
            v = round(math.log2(i) * scale)
            v = clamp_int(v, 0, 0xFFFF)
            tbl.append(v)
    return tbl

def gen_exp2_frac_table(frac_size=256, q=8):
    scale = qscale(q)
    tbl = []
    for f in range(frac_size):
        v = round((2 ** (f / frac_size)) * scale)
        v = clamp_int(v, 0, 0xFFFF)
        tbl.append(v)
    return tbl

def gen_sin_cos_table(n=512, q=15):
    scale = qscale(q)
    sin_tbl = []
    cos_tbl = []
    for i in range(n):
        angle = 2.0 * math.pi * i / n
        s = round(math.sin(angle) * scale)
        c = round(math.cos(angle) * scale)
        sin_tbl.append(clamp_int(s, -32768, 32767))
        cos_tbl.append(clamp_int(c, -32768, 32767))
    return sin_tbl, cos_tbl

def gen_perspective_table(n=256, q=8, focal=256.0, zmin=0.0, zmax=1024.0):
    scale = qscale(q)
    tbl = []
    for i in range(n):
        z = zmin + (zmax - zmin) * (i / (n - 1))
        denom = focal + z
        s = (focal / denom) if denom != 0.0 else 0.0
        v = round(s * scale)
        tbl.append(clamp_int(v, 0, 0xFFFFFFFF))
    return tbl

def gen_sphere_theta_tables(theta_steps=128, q=15):
    scale = qscale(q)
    sin_t = []
    cos_t = []
    for t in range(theta_steps):
        theta = math.pi * t / (theta_steps - 1)  # include endpoints
        s = round(math.sin(theta) * scale)
        c = round(math.cos(theta) * scale)
        sin_t.append(clamp_int(s, -32768, 32767))
        cos_t.append(clamp_int(c, -32768, 32767))
    return sin_t, cos_t

def gen_atan_table(n=1024, q=15, x_range=4.0):
    # Create a table approximating atan(y/x) for slope in [-x_range..x_range] mapped to index
    # Useful for atan/slope approximations; store result in Q format (signed)
    scale = qscale(q)
    tbl = []
    for i in range(n):
        slope = ((i / (n - 1)) * 2.0 * x_range) - x_range
        v = round(math.atan(slope) * scale)  # -pi/2..pi/2
        tbl.append(clamp_int(v, -32768, 32767))
    return tbl

def gen_stereographic_table(n=256, q=12):
    # Map (u,v) radial scaling for stereographic projection often uses factor = 2 / (1 + r^2)
    # We'll generate 1D radial mapping from r in [0..rmax] -> factor in Q
    scale = qscale(q)
    tbl = []
    rmax = 2.0
    for i in range(n):
        r = (i / (n - 1)) * rmax
        factor = 2.0 / (1.0 + r * r)
        tbl.append(round(factor * scale))
    return tbl

# ---------------------- Header writer ----------------------
def write_header(outpath: Path, opts):
    guard = "ARDUINO_TABLES_GENERATED_H"
    lines = []
    lines.append("// Auto-generated by generate_tables.py")
    lines.append(f"#ifndef {guard}")
    lines.append(f"#define {guard}\n")
    lines.append("#include <stdint.h>")
    lines.append("#include <avr/pgmspace.h>\n")

    # msb
    msb = gen_msb_table(opts.msb_size)
    lines.append("// msb table: floor(log2(n)) for n in [0..%d-1]" % opts.msb_size)
    lines.append(fmt_c_array("uint8_t", "msb_table", msb, per_line=16, progmem_macro=opts.progmem_macro))

    # log2
    log2 = gen_log2_table(opts.log_size, q=opts.log_q)
    lines.append("// log2_table_q{q}: round(log2(i) * 2^{q})".format(q=opts.log_q))
    lines.append(fmt_c_array("uint16_t", f"log2_table_q{opts.log_q}", log2, per_line=8, progmem_macro=opts.progmem_macro))

    # exp2 fractional
    exp2 = gen_exp2_frac_table(opts.exp_frac_size, q=opts.log_q)
    lines.append("// exp2_table_q{q}: fractional exp2 table for f in [0..{N}-1]".format(q=opts.log_q, N=opts.exp_frac_size))
    lines.append(fmt_c_array("uint16_t", f"exp2_table_q{opts.log_q}", exp2, per_line=8, progmem_macro=opts.progmem_macro))

    # sin/cos base table
    sin_tbl, cos_tbl = gen_sin_cos_table(opts.sin_cos_size, q=opts.sin_cos_q)
    lines.append("// sin/cos tables: size=%d, Q=%d (int16)" % (opts.sin_cos_size, opts.sin_cos_q))
    lines.append(fmt_c_array("int16_t", f"sin_table_q{opts.sin_cos_q}", sin_tbl, per_line=8, progmem_macro=opts.progmem_macro))
    lines.append(fmt_c_array("int16_t", f"cos_table_q{opts.sin_cos_q}", cos_tbl, per_line=8, progmem_macro=opts.progmem_macro))

    # perspective
    persp = gen_perspective_table(opts.persp_size, q=opts.persp_q, focal=opts.persp_focal, zmin=opts.persp_zmin, zmax=opts.persp_zmax)
    persp_type = "uint16_t" if max(persp) <= 0xFFFF else "uint32_t"
    lines.append("// perspective scale table: focal/(focal+z), Q=%d" % opts.persp_q)
    lines.append(fmt_c_array(persp_type, f"perspective_scale_table_q{opts.persp_q}", persp, per_line=8, progmem_macro=opts.progmem_macro))

    # sphere theta
    s_sin, s_cos = gen_sphere_theta_tables(opts.sphere_theta_steps, q=opts.sphere_q)
    lines.append("// sphere theta sin/cos (theta in [0..pi]) Q=%d" % opts.sphere_q)
    lines.append(fmt_c_array("int16_t", f"sphere_theta_sin_q{opts.sphere_q}", s_sin, per_line=8, progmem_macro=opts.progmem_macro))
    lines.append(fmt_c_array("int16_t", f"sphere_theta_cos_q{opts.sphere_q}", s_cos, per_line=8, progmem_macro=opts.progmem_macro))

    # optional atan table
    if opts.gen_atan:
        atan_tbl = gen_atan_table(opts.atan_size, q=opts.atan_q, x_range=opts.atan_range)
        lines.append("// atan slope table Q=%d" % opts.atan_q)
        lines.append(fmt_c_array("int16_t", f"atan_slope_table_q{opts.atan_q}", atan_tbl, per_line=8, progmem_macro=opts.progmem_macro))

    # optional stereographic table
    if opts.gen_stereo:
        stereo_tbl = gen_stereographic_table(opts.stereo_size, q=opts.stereo_q)
        st_type = "uint16_t" if max(stereo_tbl) <= 0xFFFF else "uint32_t"
        lines.append("// stereographic radial factor table Q=%d" % opts.stereo_q)
        lines.append(fmt_c_array(st_type, f"stereo_radial_table_q{opts.stereo_q}", stereo_tbl, per_line=8, progmem_macro=opts.progmem_macro))

    # base constants
    log_scale = qscale(opts.log_q)
    sin_scale = qscale(opts.sin_cos_q)
    pi_log = round(math.pi * log_scale)
    two_pi_log = round(2.0 * math.pi * log_scale)
    pi_sinq = round(math.pi * sin_scale)
    two_pi_sinq = round(2.0 * math.pi * sin_scale)
    lines.append(f"// constants (stored in PROGMEM): PI and 2PI in chosen Q formats")
    lines.append(f"const uint32_t {opts.progmem_macro} CONST_PI_LOG_Q{opts.log_q} = {pi_log};")
    lines.append(f"const uint32_t {opts.progmem_macro} CONST_2PI_LOG_Q{opts.log_q} = {two_pi_log};")
    lines.append(f"const int32_t {opts.progmem_macro} CONST_PI_SIN_Q{opts.sin_cos_q} = {pi_sinq};")
    lines.append(f"const int32_t {opts.progmem_macro} CONST_2PI_SIN_Q{opts.sin_cos_q} = {two_pi_sinq};\n")

    lines.append("#endif // " + guard + "\n")

    outpath.write_text("\n".join(lines))
    print(f"Wrote header to: {outpath}")

# ---------------------- CLI ----------------------
def parse_args():
    p = argparse.ArgumentParser(description="Generate PROGMEM lookup tables for Arduino/AVR")
    p.add_argument("--out", "-o", default="arduino_tables_generated.h", help="Output header path")
    p.add_argument("--progmem-macro", default="PROGMEM", help="Macro used to place arrays in progmem")
    p.add_argument("--msb-size", type=int, default=256)
    p.add_argument("--log-size", type=int, default=256)
    p.add_argument("--log-q", type=int, default=8)
    p.add_argument("--exp-frac-size", type=int, default=256)
    p.add_argument("--sin-cos-size", type=int, default=512)
    p.add_argument("--sin-cos-q", type=int, default=15)
    p.add_argument("--persp-size", type=int, default=256)
    p.add_argument("--persp-q", type=int, default=8)
    p.add_argument("--persp-focal", type=float, default=256.0)
    p.add_argument("--persp-zmin", type=float, default=0.0)
    p.add_argument("--persp-zmax", type=float, default=1024.0)
    p.add_argument("--sphere-theta-steps", type=int, default=128)
    p.add_argument("--sphere-q", type=int, default=15)
    p.add_argument("--gen-atan", action="store_true")
    p.add_argument("--atan-size", type=int, default=1024)
    p.add_argument("--atan-q", type=int, default=15)
    p.add_argument("--atan-range", type=float, default=4.0)
    p.add_argument("--gen-stereo", action="store_true")
    p.add_argument("--stereo-size", type=int, default=256)
    p.add_argument("--stereo-q", type=int, default=12)
    return p.parse_args()

def main():
    opts = parse_args()
    out = Path(opts.out)
    write_header(out, opts)
    print("Done. Example usage:")
    print("  - #include \"%s\"" % out.name)
    print("  - use pgm_read_word(&sin_table_q%d[idx]) to read entries (or create inline LPM helpers)" % opts.sin_cos_q)

if __name__ == "__main__":
    main()
