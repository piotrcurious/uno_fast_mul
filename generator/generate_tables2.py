#!/usr/bin/env python3
"""
generate_tables.py

Generates PROGMEM-friendly C header (or .h + .c pair) with lookup tables useful for:
 - fast log/exp-based multiplication (msb, log2, exp2)
 - trig (sin, cos)
 - perspective scale (focal/(focal+z))
 - sphere coordinates (theta sin/cos)
 - base constants (PI, 2PI in chosen Q formats)
 - optional angle (atan-approx) table and stereographic projection table

Use --emit-c to produce a header with externs and a .c file with actual PROGMEM definitions.
No external dependencies.
"""
from pathlib import Path
import math
import argparse
import textwrap
import sys

# ---------------------- Utilities ----------------------
def qscale(q): return 1 << q
def clamp_int(x, lo, hi): return max(lo, min(hi, int(x)))

def fmt_c_array(ctype, name, values, per_line=12, progmem_macro="PROGMEM"):
    lines = []
    for i in range(0, len(values), per_line):
        chunk = values[i:i+per_line]
        lines.append("  " + ", ".join(str(int(v)) for v in chunk) + ("," if i+per_line < len(values) else ""))
    body = "\n".join(lines)
    return f"const {ctype} {progmem_macro} {name}[{len(values)}] = {{\n{body}\n}};\n"

def fmt_c_array_no_progmem(ctype, name, values, per_line=12):
    # Used for .h (when emit-c) to generate externs only -> not used
    return f"extern const {ctype} {name}[{len(values)}];\n"

# ---------------------- Generators ----------------------
def gen_msb_table(size=256):
    tbl = []
    for i in range(size):
        tbl.append(0 if i == 0 else int(math.floor(math.log2(i))))
    return tbl

def gen_log2_table(size=256, q=8):
    scale = qscale(q)
    tbl = []
    for i in range(size):
        if i < 1:
            tbl.append(0)
        else:
            v = round(math.log2(i) * scale)
            v = clamp_int(v, 0, 0xFFFF)
            tbl.append(v)
    return tbl

def gen_exp2_frac_table(frac_size=256, q=8):
    scale = qscale(q)
    tbl = []
    for f in range(frac_size):
        v = round((2 ** (f / frac_size)) * scale)
        v = clamp_int(v, 0, 0xFFFF)
        tbl.append(v)
    return tbl

def gen_sin_cos_table(n=512, q=15):
    scale = qscale(q)
    sin_tbl = []
    cos_tbl = []
    for i in range(n):
        angle = 2.0 * math.pi * i / n
        s = round(math.sin(angle) * scale)
        c = round(math.cos(angle) * scale)
        sin_tbl.append(clamp_int(s, -32768, 32767))
        cos_tbl.append(clamp_int(c, -32768, 32767))
    return sin_tbl, cos_tbl

def gen_perspective_table(n=256, q=8, focal=256.0, zmin=0.0, zmax=1024.0):
    scale = qscale(q)
    tbl = []
    for i in range(n):
        z = zmin + (zmax - zmin) * (i / (n - 1))
        denom = focal + z
        s = (focal / denom) if denom != 0.0 else 0.0
        v = round(s * scale)
        tbl.append(clamp_int(v, 0, 0xFFFFFFFF))
    return tbl

def gen_sphere_theta_tables(theta_steps=128, q=15):
    scale = qscale(q)
    sin_t = []
    cos_t = []
    for t in range(theta_steps):
        theta = math.pi * t / (theta_steps - 1)
        s = round(math.sin(theta) * scale)
        c = round(math.cos(theta) * scale)
        sin_t.append(clamp_int(s, -32768, 32767))
        cos_t.append(clamp_int(c, -32768, 32767))
    return sin_t, cos_t

def gen_atan_table(n=1024, q=15, x_range=4.0):
    scale = qscale(q)
    tbl = []
    for i in range(n):
        slope = ((i / (n - 1)) * 2.0 * x_range) - x_range
        v = round(math.atan(slope) * scale)
        tbl.append(clamp_int(v, -32768, 32767))
    return tbl

def gen_stereographic_table(n=256, q=12):
    scale = qscale(q)
    tbl = []
    rmax = 2.0
    for i in range(n):
        r = (i / (n - 1)) * rmax
        factor = 2.0 / (1.0 + r * r)
        tbl.append(round(factor * scale))
    return tbl

# ---------------------- Writer helpers ----------------------
def make_header_content_tables(opts, arrays_meta, emit_c=False):
    """
    If emit_c==False: produce header with definitions of arrays (const ... PROGMEM ...)
    If emit_c==True: produce header with extern declarations only.
    arrays_meta: list of dicts {name, ctype, values}
    """
    guard = (opts.header_guard or "ARDUINO_TABLES_GENERATED_H").upper()
    lines = []
    lines.append("// Auto-generated by generate_tables.py")
    lines.append(f"#ifndef {guard}")
    lines.append(f"#define {guard}\n")
    lines.append("#include <stdint.h>")
    if not emit_c:
        lines.append("#include <avr/pgmspace.h>\n")
    else:
        # header with externs also needs avr/pgmspace.h for PROGMEM macro type in externs
        lines.append("#include <avr/pgmspace.h>\n")

    for meta in arrays_meta:
        name = meta["name"]
        ctype = meta["ctype"]
        vals = meta["values"]
        if emit_c:
            # extern declaration (no PROGMEM here because extern refers to symbol defined in .c)
            lines.append(f"extern const {ctype} {opts.progmem_macro} {name}[{len(vals)}];\n")
        else:
            # full definition placed in header (no separate .c)
            lines.append(fmt_c_array(ctype, name, vals, per_line=opts.per_line, progmem_macro=opts.progmem_macro))

    # constants (store in PROGMEM too)
    log_scale = qscale(opts.log_q)
    sin_scale = qscale(opts.sin_cos_q)
    pi_log = round(math.pi * log_scale)
    two_pi_log = round(2.0 * math.pi * log_scale)
    pi_sinq = round(math.pi * sin_scale)
    two_pi_sinq = round(2.0 * math.pi * sin_scale)
    if emit_c:
        lines.append(f"extern const uint32_t {opts.progmem_macro} CONST_PI_LOG_Q{opts.log_q};")
        lines.append(f"extern const uint32_t {opts.progmem_macro} CONST_2PI_LOG_Q{opts.log_q};")
        lines.append(f"extern const int32_t {opts.progmem_macro} CONST_PI_SIN_Q{opts.sin_cos_q};")
        lines.append(f"extern const int32_t {opts.progmem_macro} CONST_2PI_SIN_Q{opts.sin_cos_q};\n")
    else:
        lines.append(f"const uint32_t {opts.progmem_macro} CONST_PI_LOG_Q{opts.log_q} = {pi_log};")
        lines.append(f"const uint32_t {opts.progmem_macro} CONST_2PI_LOG_Q{opts.log_q} = {two_pi_log};")
        lines.append(f"const int32_t {opts.progmem_macro} CONST_PI_SIN_Q{opts.sin_cos_q} = {pi_sinq};")
        lines.append(f"const int32_t {opts.progmem_macro} CONST_2PI_SIN_Q{opts.sin_cos_q} = {two_pi_sinq};\n")

    lines.append("#endif // " + guard + "\n")
    return "\n".join(lines)

def make_c_content_tables(opts, arrays_meta, header_name):
    """Create the .c file that includes header and defines arrays (with PROGMEM)."""
    lines = []
    lines.append("// Auto-generated definitions for lookup tables (generate_tables.py --emit-c)")
    lines.append(f'#include "{header_name}"\n')
    # define arrays (we rely on same fmt as header definitions used earlier)
    for meta in arrays_meta:
        name = meta["name"]
        ctype = meta["ctype"]
        vals = meta["values"]
        lines.append(fmt_c_array(ctype, name, vals, per_line=opts.per_line, progmem_macro=opts.progmem_macro))
    # constants with PROGMEM
    log_scale = qscale(opts.log_q)
    sin_scale = qscale(opts.sin_cos_q)
    pi_log = round(math.pi * log_scale)
    two_pi_log = round(2.0 * math.pi * log_scale)
    pi_sinq = round(math.pi * sin_scale)
    two_pi_sinq = round(2.0 * math.pi * sin_scale)
    lines.append(f"const uint32_t {opts.progmem_macro} CONST_PI_LOG_Q{opts.log_q} = {pi_log};")
    lines.append(f"const uint32_t {opts.progmem_macro} CONST_2PI_LOG_Q{opts.log_q} = {two_pi_log};")
    lines.append(f"const int32_t {opts.progmem_macro} CONST_PI_SIN_Q{opts.sin_cos_q} = {pi_sinq};")
    lines.append(f"const int32_t {opts.progmem_macro} CONST_2PI_SIN_Q{opts.sin_cos_q} = {two_pi_sinq};\n")
    return "\n".join(lines)

# ---------------------- High-level writer ----------------------
def generate_all_tables(opts):
    arrays_meta = []

    # msb
    msb = gen_msb_table(opts.msb_size)
    arrays_meta.append({"name":"msb_table", "ctype":"uint8_t", "values":msb})

    # log2
    log2 = gen_log2_table(opts.log_size, q=opts.log_q)
    arrays_meta.append({"name":f"log2_table_q{opts.log_q}", "ctype":"uint16_t", "values":log2})

    # exp2
    exp2 = gen_exp2_frac_table(opts.exp_frac_size, q=opts.log_q)
    arrays_meta.append({"name":f"exp2_table_q{opts.log_q}", "ctype":"uint16_t", "values":exp2})

    # sin/cos
    sin_tbl, cos_tbl = gen_sin_cos_table(opts.sin_cos_size, q=opts.sin_cos_q)
    arrays_meta.append({"name":f"sin_table_q{opts.sin_cos_q}", "ctype":"int16_t", "values":sin_tbl})
    arrays_meta.append({"name":f"cos_table_q{opts.sin_cos_q}", "ctype":"int16_t", "values":cos_tbl})

    # perspective
    persp = gen_perspective_table(opts.persp_size, q=opts.persp_q, focal=opts.persp_focal, zmin=opts.persp_zmin, zmax=opts.persp_zmax)
    persp_type = "uint16_t" if max(persp) <= 0xFFFF else "uint32_t"
    arrays_meta.append({"name":f"perspective_scale_table_q{opts.persp_q}", "ctype":persp_type, "values":persp})

    # sphere theta
    s_sin, s_cos = gen_sphere_theta_tables(opts.sphere_theta_steps, q=opts.sphere_q)
    arrays_meta.append({"name":f"sphere_theta_sin_q{opts.sphere_q}", "ctype":"int16_t", "values":s_sin})
    arrays_meta.append({"name":f"sphere_theta_cos_q{opts.sphere_q}", "ctype":"int16_t", "values":s_cos})

    # optional atan
    if opts.gen_atan:
        atan_tbl = gen_atan_table(opts.atan_size, q=opts.atan_q, x_range=opts.atan_range)
        arrays_meta.append({"name":f"atan_slope_table_q{opts.atan_q}", "ctype":"int16_t", "values":atan_tbl})

    # optional stereo
    if opts.gen_stereo:
        stereo_tbl = gen_stereographic_table(opts.stereo_size, q=opts.stereo_q)
        st_type = "uint16_t" if max(stereo_tbl) <= 0xFFFF else "uint32_t"
        arrays_meta.append({"name":f"stereo_radial_table_q{opts.stereo_q}", "ctype":st_type, "values":stereo_tbl})

    return arrays_meta

# ---------------------- CLI ----------------------
def parse_args():
    p = argparse.ArgumentParser(description="Generate PROGMEM lookup tables for Arduino/AVR")
    p.add_argument("--out", "-o", default="arduino_tables_generated", help="Base output filename (without extension). Writes <out>.h and optionally <out>.c")
    p.add_argument("--progmem-macro", default="PROGMEM", help="Macro used to place arrays in progmem")
    p.add_argument("--emit-c", action="store_true", help="Emit a .c file with definitions and a header with externs (instead of single header with definitions)")

    p.add_argument("--msb-size", type=int, default=256)
    p.add_argument("--log-size", type=int, default=256)
    p.add_argument("--log-q", type=int, default=8)
    p.add_argument("--exp-frac-size", type=int, default=256)
    p.add_argument("--sin-cos-size", type=int, default=512)
    p.add_argument("--sin-cos-q", type=int, default=15)
    p.add_argument("--persp-size", type=int, default=256)
    p.add_argument("--persp-q", type=int, default=8)
    p.add_argument("--persp-focal", type=float, default=256.0)
    p.add_argument("--persp-zmin", type=float, default=0.0)
    p.add_argument("--persp-zmax", type=float, default=1024.0)
    p.add_argument("--sphere-theta-steps", type=int, default=128)
    p.add_argument("--sphere-q", type=int, default=15)
    p.add_argument("--gen-atan", action="store_true")
    p.add_argument("--atan-size", type=int, default=1024)
    p.add_argument("--atan-q", type=int, default=15)
    p.add_argument("--atan-range", type=float, default=4.0)
    p.add_argument("--gen-stereo", action="store_true")
    p.add_argument("--stereo-size", type=int, default=256)
    p.add_argument("--stereo-q", type=int, default=12)

    p.add_argument("--per-line", type=int, default=8, help="Items per line in generated arrays")
    p.add_argument("--header-guard", default="", help="Optional header guard override (defaults to ARDUINO_TABLES_GENERATED_H)")

    return p.parse_args()

def main():
    opts = parse_args()
    base = Path(opts.out)
    header_path = base.with_suffix(".h")
    c_path = base.with_suffix(".c")

    # generate arrays meta
    arrays_meta = generate_all_tables(opts)

    if opts.emit_c:
        # create header with externs
        header_content = make_header_content_tables(opts, arrays_meta, emit_c=True)
        header_path.write_text(header_content)
        # create .c with actual definitions
        c_content = make_c_content_tables(opts, arrays_meta, header_path.name)
        c_path.write_text(c_content)
        print(f"Wrote header with externs: {header_path}")
        print(f"Wrote C definitions file: {c_path}")
    else:
        # single header with definitions
        header_content = make_header_content_tables(opts, arrays_meta, emit_c=False)
        header_path.write_text(header_content)
        print(f"Wrote single header with definitions: {header_path}")

    print("Done. Example usage in Arduino (emit-c):")
    if opts.emit_c:
        print(f'  #include "{header_path.name}"')
        print("  // Use pgm_read_word(&sin_table_q15[idx]) or create inline LPM readers for speed")
    else:
        print(f'  #include "{header_path.name}"')
        print("  // Tables are defined in the header (PROGMEM). Use pgm_read_word/pgm_read_byte to fetch.")

if __name__ == "__main__":
    main()
